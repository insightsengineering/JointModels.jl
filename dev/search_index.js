var documenterSearchIndex = {"docs":
[{"location":"HazardBasedDistribution/#Hazard-Based-Distributions","page":"Hazard Based Distributions","title":"Hazard Based Distributions","text":"","category":"section"},{"location":"HazardBasedDistribution/","page":"Hazard Based Distributions","title":"Hazard Based Distributions","text":"Abstract type describing a distribution based on the hazard funciton.","category":"page"},{"location":"HazardBasedDistribution/","page":"Hazard Based Distributions","title":"Hazard Based Distributions","text":"JointModels.HazardBasedDistribution","category":"page"},{"location":"HazardBasedDistribution/#JointModels.HazardBasedDistribution","page":"Hazard Based Distributions","title":"JointModels.HazardBasedDistribution","text":"HazardBasedDistribution <: ContinuousUnivariateDistribution\n\nHazardBasedDistribution is a type that builds a distribution based  on a hazard function.\n\nTo use this type to formulate a distribution yourself: implement a struct and the hazard function.\n\nstruct LogLogistic <: HazardBasedDistribution\n    α::Real\n    β::Real\nend\n\nfunction JointModels.hazard(dist::LogLogistic, t::Real)\n    α, β  = dist.α, dist.β\n    return ((β / α) * (t / α) ^ (β - 1)) / (1 + (t / α) ^ β)\nend\n\nHazardBasedDistribution implements numeric integration to calculate the  cumulative hazard and builds a distribution based it. To generate samples it solves an ODE and applies inverse transform sampling.\n\n\n\n\n\n","category":"type"},{"location":"HazardBasedDistribution/","page":"Hazard Based Distributions","title":"Hazard Based Distributions","text":"The Distributions.jl functionalities implemented for HazardBasedDistribution.","category":"page"},{"location":"HazardBasedDistribution/","page":"Hazard Based Distributions","title":"Hazard Based Distributions","text":"JointModels.hazard(dist::HazardBasedDistribution, t::Real)\nJointModels.cumulative_hazard(dist::HazardBasedDistribution, t::Real)\nBase.rand(rng::AbstractRNG, dist::HazardBasedDistribution)\nDistributions.ccdf(dist::HazardBasedDistribution, t::Real)\nDistributions.logpdf(dist::HazardBasedDistribution, t::Real)\nDistributions.pdf(dist::HazardBasedDistribution, t::Real)","category":"page"},{"location":"HazardBasedDistribution/#JointModels.hazard-Tuple{HazardBasedDistribution, Real}","page":"Hazard Based Distributions","title":"JointModels.hazard","text":"represents h(t) needs to be implemented for any struct that subtypes HazardBasedDistribution\n\n\n\n\n\n","category":"method"},{"location":"HazardBasedDistribution/#JointModels.cumulative_hazard-Tuple{HazardBasedDistribution, Real}","page":"Hazard Based Distributions","title":"JointModels.cumulative_hazard","text":"calculates H(t) = int_0^t h(u)  du numerically with a  Gauss-Konrad procedure.\n\n\n\n\n\n","category":"method"},{"location":"HazardBasedDistribution/#Base.rand-Tuple{AbstractRNG, HazardBasedDistribution}","page":"Hazard Based Distributions","title":"Base.rand","text":"Generate a random sample t sim textdist via inverse transform  sampling.\n\n\n\n\n\n","category":"method"},{"location":"HazardBasedDistribution/#Distributions.ccdf-Tuple{HazardBasedDistribution, Real}","page":"Hazard Based Distributions","title":"Distributions.ccdf","text":"Calculation of the ccdf / survival function at time t based on the  cumulative hazard\n\nS(t) = exp(-H(t)) = exp(-int h(u) du)\n\n\n\n\n\n","category":"method"},{"location":"HazardBasedDistribution/#Distributions.logpdf-Tuple{HazardBasedDistribution, Real}","page":"Hazard Based Distributions","title":"Distributions.logpdf","text":"Calculation of the log pdf function at time t based on the cumulative hazard \n\nlog (f(t)) = log(h(t)cdot S(t)) = log( h(t)) - H(t)\n\n\n\n\n\n","category":"method"},{"location":"HazardBasedDistribution/#Distributions.pdf-Tuple{HazardBasedDistribution, Real}","page":"Hazard Based Distributions","title":"Distributions.pdf","text":"Calculation of the pdf function at time t based on the log pdf.\n\n\n\n\n\n","category":"method"},{"location":"GeneralJointModel/#General-Joint-Model","page":"General Joint Model","title":"General Joint Model","text":"","category":"section"},{"location":"GeneralJointModel/","page":"General Joint Model","title":"General Joint Model","text":"This struct implements a general family of joint models. Let h_0mathbbR tomathbbR_+ be a baseline hazard function. Suppose we have kin mathbbN longitudinal models m_1dots m_ksubset textFunctions mathbbRtomathbbR as well as k links l_1dots l_ksubset textOperators on functions mathbbRtomathbbR. Let M mathbbR to mathbbR^k and LmathbbR^k to mathbbR^k be the multidimensional vector versions","category":"page"},{"location":"GeneralJointModel/","page":"General Joint Model","title":"General Joint Model","text":"beginalign*\n    M(t) mapsto beginpmatrix\n    m_1(t)  m_2(t)  dots  m_k(t)\nendpmatrix text \n    Lbeginpmatrix\n    mu_1  mu_2  dots  mu_k\nendpmatrix mapsto beginpmatrix\n    l_1(mu_1)  l_2(mu_2)  dots  l_k(mu_k)\nendpmatrix text and  L(M(t)) =beginpmatrix\n    l_1(m_1(t))  l_2(m_2(t))  dots  l_k(m_k(t))\nendpmatrix\nendalign*","category":"page"},{"location":"GeneralJointModel/","page":"General Joint Model","title":"General Joint Model","text":"In code L(M(t)) corresponds to an array of unary functions (one argument). You are responsible for choosing the longitudinal model and link and finally the application of the link to the longitudinal model. For the link model vector L(M(t)) we consider a coefficient vector b in mathbbR^k. Then we can formulate a hazard as follows","category":"page"},{"location":"GeneralJointModel/","page":"General Joint Model","title":"General Joint Model","text":"h(t) = h_0(t) expleft(sum_jin kb_j l_j(m_j(t))  right) = h_0(t) exp(b cdot L(M(t)))","category":"page"},{"location":"GeneralJointModel/","page":"General Joint Model","title":"General Joint Model","text":"Additionally we consider covariates xin mathbbR^l linmathbbN and coefficients beta in mathbbR^l. This results in the hazard","category":"page"},{"location":"GeneralJointModel/","page":"General Joint Model","title":"General Joint Model","text":"beginalign*\nh(t) = h_0(t) expleft(b cdot L(M(t)) + beta cdot xright)\n     = h_0(t) expleft(sum_jin kb_j l_j(m_j(t)) + sum_jin l x_j  beta_j  right)\nendalign*","category":"page"},{"location":"GeneralJointModel/","page":"General Joint Model","title":"General Joint Model","text":"which is implemented in the general joint model:","category":"page"},{"location":"GeneralJointModel/","page":"General Joint Model","title":"General Joint Model","text":"JointModels.GeneralJointModel","category":"page"},{"location":"GeneralJointModel/#JointModels.GeneralJointModel","page":"General Joint Model","title":"JointModels.GeneralJointModel","text":"GeneralJointModel <: HazardBasedDistribution <: ContinuousUnivariateDistribution\n\nGeneralJointModel is based on the hazard formulation:\n\nh_i(t) = h_0(t) expleft(b cdot L(M_i (t)) + beta cdot x right)\n\nwhere h_0 mathbbR to mathbbR_+ is the baseline hazard function. The term L(M(t)) mathbbR to mathbbR^k kinmathbbN represents the link to the longitudinal model(s)  and binmathbbR^k are the link coefficients. Lastly x inmathbbR^l linmathbbN the covariates with coefficients betainmathbbR^l.\n\nFields:\n\nh₀::Function: a positive valued function in time representing the baseline hazard\nb::Vector{Real}: coefficients for links to longitudinal models, should have the same length as link_m\nlink_m::Vector{Function}: unary functions (one argument) in time representing the link to a single or multiple longitudinal models\nβ::Vector{Real}: coefficients for covariates, should have the same length as x\nx::Vector{Real}: covariates\n\nExample\n\nThere are constructors for calling GeneralJointModel without covariates and for single longitudinal models without the need for arrays. For example:\n\nusing JointModels\n\nGeneralJointModel(identity, 0.01, identity, 0.02, 3)\n# corresponds to hazard: identity(t) * exp(0.01 * identity(t) +  0.02 * 3) \nGeneralJointModel(identity, 0.01, identity)\n# corresponds to hazard: identity(t) * exp(0.01 * identity(t))\nGeneralJointModel(identity,\n                    [0.01,-0.02,0.03],\n                    [x -> sqrt(x), x -> sin(x)+1, x -> cos(x)^2],\n                    [2, 0.3],\n                    [ 0, sqrt(2)])\n# corresponds to hazard: identity(t) * exp(0.01 * sqrt(t) - 0.02 * (sin(t)+1) + 0.03 * cos(t)^2  + 2 * 0 + 0.3 * sqrt(2))\n\n\n\n\n\n","category":"type"},{"location":"GeneralJointModel/","page":"General Joint Model","title":"General Joint Model","text":"Its hazard is calculated by:","category":"page"},{"location":"GeneralJointModel/","page":"General Joint Model","title":"General Joint Model","text":"JointModels.hazard(jm::GeneralJointModel, t::Real)","category":"page"},{"location":"GeneralJointModel/#JointModels.hazard-Tuple{GeneralJointModel, Real}","page":"General Joint Model","title":"JointModels.hazard","text":"The hazard for GeneralJointModel calculates the hazard according to the formulation h(t) = h_0(t) expleft(b cdot L(M(t)) + beta cdot x right) described in the documentation of GeneralJointModel\n\n\n\n\n\n","category":"method"},{"location":"#JointModels.jl","page":"JointModels.jl","title":"JointModels.jl","text":"","category":"section"},{"location":"","page":"JointModels.jl","title":"JointModels.jl","text":"Documentation for JointModels.jl","category":"page"},{"location":"","page":"JointModels.jl","title":"JointModels.jl","text":"This package implements a distribution HazardBasedDistribution that allows you to specify the hazard in any way you want, including Joint Model formulations.","category":"page"},{"location":"","page":"JointModels.jl","title":"JointModels.jl","text":"","category":"page"}]
}
